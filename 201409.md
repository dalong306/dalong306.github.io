##2014-9-1
######juqery
``` e.originalEvent.changedTouches || e.originalEvent.touches
```

######insertAdjacentHTML

>1.beforeBegin: 插入到标签开始前

>2.afterBegin:插入到标签开始标记之后

>3.beforeEnd:插入到标签结束标记前

>4.afterEnd:插入到标签结束标记后


######	window.onload
```
setTimeout(scrollTo, 0, 0, 250);
```

######	canvas
>300*150

> beginPath方法表示开始绘制路径

> moveTo(x, y)方法设置线段的起点

> moveTo(x, y)方法设置线段的起点

##2014-9-2
######	px, em, rem
>px像素（Pixel）。相对长度单位
>
>em相对于父级元素! 
>
>rem（root em）是相对于根元素
>
######	canvas
##2014-9-3
######	deferred
> $.Deferred() 生成一个deferred对象
> 
>  deferred.done() 指定操作成功时的回调函数
>  
>  deferred.fail() 指定操作失败时的回调函数
>  
>   deferred.promise() 没有参数时，返回一个新的deferred对象，该对象的运行状态无法被改变；接受参数时，作用为在参数对象上部署deferred接口。
>   
>   deferred.resolve() 手动改变deferred对象的运行状态为"已完成"，从而立即触发done()方法。
>   
>   deferred.reject() 这个方法与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为"已失败"，从而立即触发fail()方法。
>   
>    $.when() 为多个操作指定回调函数。
>    
>    deferred.then() 如果then()有两个参数，那么第一个参数是done()方法的回调函数，第二个参数是fail()方法的回调方法。如果then()只有一个参数，那么等同于done()。
>    
>    deferred.always()不管调用的是deferred.resolve()还是deferred.reject()，最后总是执行。
>    
>    deferred.pipe( deferred.pipe( [doneFilter ] [, failFilter ] [, progressFilter ] ) )
>    从jQuery 1.8开始, deferred.pipe() 方法过时. 应该使用deferred.then() 代替它。


>    doneFilter一个函数，或者函数数组，当Deferred（延迟）对象得到解决时被调用。
>   failFilter 一个函数，或者函数数组，当Deferred（延迟）对象得到拒绝时被调用。
>   progressFilter一个可选的函数，当进度通知发送给Deferred（延迟）被调用。

######	Backbone
>underscore要在backbone前面
>Collection就是一个Model集合。因为Model是一条数据记录，也就是说，Collection相当于是一个数据集。

##2014-9-4
######	Backbone - Model Collection Router History View Sync Event
######	Model 
>create save()
>read fetch()
>update set()
>delete destroy()
>set({name:""}) 时将不会触发validate校验
>版本(0.9.10)里，validate只在save的时候触发
######	Router
>页面加载期间，当应用已经创建了所有的路由，需要调用 Backbone.history.start()，或 Backbone.history.start({pushState : true}) 来确保驱动初始化 URL 的路由。
######	Sync
>Backbone.sync 是 Backbone 每次向服务器读取或保存模型时都要调用执行的函数。
######	View
>在 render 函数的末尾 return this 以开启链式调用

##2014-9-5
######	Backbone
>模型Model绑定键值数据和自定义事件；
>集合Colection是模型的有序或无序集合，带有丰富的可枚举API； 
>视图View声明事件监听函数；
>将模型、集合、视图与服务端的RESTful JSON接口连接。
> Backbone.Events        // 自定义事件
>  Backbone.Model        // 模型构造函数和原型扩展
>   Backbone.Collection    // 集合构造函数和原型扩展
>   Backbone.Router        // 路由配置器构造函数和原型扩展
>   Backbone.History        // 路由器构造函数和原型扩展
>   Backbone.View            // 视图构造函数和原型扩展
>   Backbone.sync            // 异步请求工具方法
>    var extend = function (protoProps, classProps) { ... } // 自扩展函数
>     Backbone.Model.extend = Backbone.Collection.extend = Backbone.Router.extend = Backbone.View.extend = extend; // 自扩展方法
######	Collection
>reset()，它允许将多个模型设置到一个集合中
>要操作来自服务器的原始数据，可以使用集合的 parse() 方法
>如果同时设置了urlRoot和url参数，url参数的优先级会高于urlRoot
>前端跟服务器端交换数据无非两种方式：Backbone模型的CURD和集合的拉取，Jquery AJAX
>//fetch用于刷新模型，该函数会请求数据，若是远程数据和当前模型不一致，将触发change事件
>在backbone视图读取或者保存模型到服务器时都会调用backbone.sync方法，


##2014-9-9
######	$.cookie zepto.js


##2014-9-10
######	ipod fixed:show()：bug display:block; 输入框存在时底部空隙增加40px;

##2014-9-11
######	Backbone
>json格式不正确会进入error函数
>
>用Backbone.Model表示应用中所有数据，models中的数据可以创建、校验、销毁和保存到服务端。
当models中值被改变时自动触发一个"change"事件、所有用于展示models数据的views都会侦听到这个事件，然后进行重新渲染。
Backbone.Collection和我们平时接触的JAVA集合类相似，具有增加元素，删除元素，获取长度，排序，比较等一系列工具方法，说白了就是一个保存models的集合类。
Backbone.View中可以绑定dom el和客户端事件。页面中的html就是通过views的render方法渲染出来的，当新建一个view的时候通过要传进一个model作为数据

>前端跟服务器端交换数据无非两种方式：Backbone模型的CURD和集合的拉取，Jquery AJAX。

##2014-9-12
>记住卸载unbind()
######	RESTful


######	Promise

##2014-9-16
>factory prototype this????？？
>Y方向滚动、断片以及body滚动问题 overflow-y:auto;-webkit-overflow-scrolling:touch; 

##2014-9-17
>radio attr("checked", true)失效，改为prop("checked", true)
>读取 原生boolean属性，attr读得不准
>一般只有读取  selected，selectedIndex等boolean值或索引时才会考虑用prop。
>如果是自定义属性，attr可以读到。prop读不到。


##2014-9-18
>url中有中文时解析成字符串 escape,encodeURI,encodeURIComponent，相应3个解码函数：unescape,decodeURI,decodeURIComponent 。
>数据动态加载如何回调？？？？？？
>两个页面的全局变量true false?????

##2014-9-19
######	Collection
>create: 在集合中创建一个模型。 等价于用键值对象实例一个模型，然后将模型保存到服务器，保存成功后将模型增加到集合中<br/>
>reset<br/>
>trigger自定义触发事件<br/>
######	Collection
>save   如果模型 isNew, 保存将采用 "create" (HTTP POST) 方法, 如果模型已经在服务器存在，保存将采用 "update" (HTTP PUT) 方法.<br/>

##2014-9-22
######	JSON
>1） 并列的数据之间用逗号（“，”）分隔。<br/> 
2） 映射用冒号（“：”）表示。 <br/>
3） 并列数据的集合（数组）用方括号("[]")表示。<br/> 
4） 映射的集合（对象）用大括号（“{}”）表示。<br/>
按照这个规则可以作以下理解： <br/>
1.数组用“[]”创建，对象用“{}”创建，并且使用Json基本都是用[]或者{}创建的数组或对象，否则一个普通的字符串是没有意义的；<br/> 
2.无论是数组还是对象，之间的元素都用“，”隔开； <br/>
3.对象内部，（属性的）名称和值用“：”隔开，并且必须要用“：”隔开，不可单独存在属性名或者值； <br/>
4.对象和数组可以互相嵌套，即数组中的一个元素可以是一个对象也可以是一个数组，同理对象中的一个属性的值可以是一个对象也可以是一个数组。<br/>


<b style="color:#FF0000">很严重的一个问题：遇到问题不要去问，先自己思考，习惯自己去问别人会有依赖</b>
######	Collection
>collection在fetch到数据之后，会调用reset方法，所以你需要在collection中定义reset方法或者是绑定reset方法<br/>

##2014-9-23 NODEJS
	npm install -g supervisor 监视你对代码的改动，并自动重启Node.js
	npm install forever -g  让nodejs应用后台执行

######## express

	npm install express-generator -g创建web应用

######## moduel.exports和exports区别

>	exports可以认为是module.exports的添加接口，如果是module.exports有定义引入，exports也有定义引入，那对外暴露的接口是module.exports定义的，而不是exports定义的，module.exports把exports覆盖了。另外一个区别是exports只能引出obj，而module.exports可以引出数据类型，像数组、字符串、数字都ok。<br/><br/>
>	
		
	ctrl+C退出服务 
	supervisor app.js 全局安装，方便修改不需要重启

##2014-9-24 NODEJS
>uc浏览器会屏弊客户端 url处理

	parseInt("99ab") == 99

>node.js本来就是一个http服务器，它是要与前端交互的，因此少不了两个对象：请求(request)与响应(response)
>
	fs模块: 此页的内容读出来，返给用户
	request.url属性处理js与css文件的请求
	res.writeHead()
    res.end()









